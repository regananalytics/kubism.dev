# kubism.dev
Kubism is an open-source platform in development by Regan Analytics LLC that allows users to design and deploy interrelated software modules, known as Objects, that run on one or more processing nodes managed by a container swarm manager such as Docker Swarm or Kubernetes. Users can define relationships between different systems (or Objects) in a Model, push software to each of those systems in the form of containers, and monitor the state of the Model from a web interface. Applications for Kubism include the modeling and simulation of complex systems-of-systems architectures. For example, a Kubism Model could drive a digital twin model of a fleet of vehicles, where Objects are created to represent the functional subsystems of real or simulated vehicles. Vehicle state information is monitored and can be used to optimize fleet maintenance and conduct predictive analytics. Kubism could also be used to drive small Internet of Things (IOT) projects to network smart home systems. As a third example, Kubism could be used as the development platform for an infrastructure monitoring system to identify overtasked network access points in a business or public place. The goal of Kubism is to enable “effortlessly distributable” modular software applications that can be deployed across any number of host devices, whether in the cloud, on operational hardware, or on development platforms like RaspberryPi or NVIDIA Jetson. Kubism aims to enable the future of predictive analytics and monitoring of complex system architectures.

The user defines a Model of Objects using a Python API and/or YAML files. The Model defines vertical or horizontal relationships between Objects and defines the state of each object as a collection of Fields of specified data types. Object instances are defined with a unique ID, and a type. Each Object type shares the same Field definitions, but each Object instance can have different values in each Field.

The Kubism engine takes the user-defined Model and for each Object generates a remote State database which will be used to store the state of all Fields for each Object instance, as well as relationship information from the Model definition. Three tables are generated for each Object: a Delta “Δ” Table containing Field data, a Gamma “Γ” Table containing scope information and network information about related Objects, and a Lambda “Λ” Table containing module add, delete, update, or other metainformation about the module. The database has the form of a SQL-like database such as PostgreSQL, SQLite, etc. The standard database format allows for easy integration of third-party data visualization utilities.

The Kubism engine creates a docker image and deploys one or more docker containers or Kubernetes pods for each Object type in the Model, as well as a container for the main executable. Each Object definition includes a manifest of App executables which are executed within the Object container during runtime. App executables report the state of the Object, whether it is based upon a modeled relationship between the Fields of sub-Objects, or readings from real-world sensors. The App files are python scripts by default but can be written in any user-preferred language so long as they can interface with the Kubism deployment API. The Kubism deployment API is used by the App executables to query and post state information to the State database, and to call any Object containers with which they have a defined relationship within the Model. The Kubism engine networks the containers within the swarm based upon the relationship definitions in the Model. A defining characteristic of the Kubism platform is that the Object containers are intended to be stateless (or as close to stateless as possible) and rely upon the Field data in the State database to determine the state of the module at any point in time. By deploying the Objects in a stateless manner, multiple replicas of each Object can be deployed across computing nodes. Calls from the main executable or other containers can then be load balanced across nodes to improve the overall performance of the simulation. Alternatively, in a limited computing environment, identical Objects can be controlled by a single deployed container. Calls to a container include the ID of the Object for which the request was made, and an object container can query state information from the State database to compute the instantaneous state of any Objects of that type.

The stateless nature of Kubism deployment allows for Object definition updates on-the-fly as supported by the DevOps nature of Docker and Kubernetes. This allows for changes to Fields, relationships between Objects, or container code changes to be pushed during runtime. Any changes executed in this fashion are recorded in the Lambda Table for each Object.

The intent is to expand the flexibility of Kubism to support interfaces with non-containerized Objects, e.g. hardware or third-party systems that do not support Docker or Kubernetes. This future change would allow users to network real-world systems with software ones for applications such as monitoring a fleet of vehicles, developing software with hardware-in-the-loop, or recording the state of host systems.
